{"version":3,"sources":["dom.js"],"names":["window","dom","create","string","container","document","createElement","innerHTML","trim","content","firstChild","after","node","node2","parentNode","insertBefore","nextSiblings","before","append","parent","appendChild","wrap","remove","removeChild","empty","array","push","attr","name","value","arguments","length","setAttribute","getAttribute","text","innerText","textContent","html","style","Object","key","class","add","className","classList","has","contains","on","eventName","fn","addEventListener","off","removeEventListener","find","selector","nodescope","querySelectorAll","children","siblings","Array","from","filter","n","next","x","nextSibling","nodeType","previous","previousSibling","each","nodeList","i","call","index","list"],"mappings":"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","file":"dom.936babd6.map","sourceRoot":"..\\src","sourcesContent":["/*\r\n再一个对象上添加方法：\r\n旧方法是：dom{\r\n    create:function(){\r\n        语句...\r\n    }\r\n} \r\n新方法是：dom{\r\n    直接写函数，不用加function了\r\n    create(){\r\n        语句...\r\n    }\r\n}\r\n */\r\n//在window上面创建一个dom对象\r\nwindow.dom = {\r\n    //创建元素\r\n    create(string) {\r\n        //template标签可以容纳所有标签，但是内容却不会显示在HTML中，比如div里面是不能容纳td标签的，写了跟没写一样\r\n        const container = document.createElement(\"template\");\r\n        container.innerHTML = string.trim(); //去除参数两边空格\r\n        return container.content.firstChild; //使用template时，获取它里面的元素需要使用content\r\n    },\r\n    //在节点后面新增节点after(节点, 新增的节点)\r\n    after(node, node2) {\r\n        node.parentNode.insertBefore(node2, node.nextSiblings);\r\n    },\r\n    //在节点前面新增节点 before(节点, 新增的节点)\r\n    before(node, node2) {\r\n        node.parentNode.insertBefore(node2, node);\r\n    },\r\n    //添加节点append(父级节点，被添加的节点)\r\n    append(parent, node) {\r\n        parent.appendChild(node);\r\n    },\r\n    //包裹子级节点 wrap(子级节点，父级节点)\r\n    wrap(node, parent) {\r\n        dom.before(node, parent);\r\n        dom.append(parent, node);\r\n    },\r\n    //删除节点remove(要删除的节点)\r\n    remove(node) {\r\n        node.parentNode.removeChild(node);\r\n        return node; //删除节点后返回该节点的引用\r\n    },\r\n    //删除父级节点的全部子节点empty(父级节点)，并以数组形式返回所有被删除节点的引用\r\n    empty(node) {\r\n        const array = [];\r\n        while (node.firstChild) {\r\n            array.push(dom.remove(node.firstChild))\r\n        }\r\n        return array;\r\n    },\r\n    //设置属性和读取属性attr(节点，属性名，属性值)\r\n    attr(node, name, value) {\r\n        if (arguments.length === 3) { //重载，根据函数参数的不同去实现不同的功能叫做重载\r\n            node.setAttribute(name, value);\r\n        } else if (arguments.length === 2) {\r\n            return node.getAttribute(name);\r\n        }\r\n    },\r\n    //设置和获取节点文本内容text(节点，文本内容)\r\n    text(node, string) {\r\n        if (arguments.length === 2) {\r\n            //适配旧款IE和新版浏览器\r\n            if (\"innerText\" in node) {\r\n                node.innerText = string;\r\n            } else {\r\n                node.textContent = string;\r\n            }\r\n        } else if (arguments.length === 1) {\r\n            if (\"innerText\" in node) {\r\n                return node.innerText;\r\n            } else {\r\n                return node.textContent;\r\n            }\r\n        }\r\n    },\r\n    //设置和获取节点内容html(节点，所有内容)\r\n    html(node, string) {\r\n        if (arguments.length === 2) {\r\n            node.innerHTML = string;\r\n        } else if (arguments.length === 1) {\r\n            return node.innerHTML;\r\n        }\r\n    },\r\n    //设置和获取节点样式(节点,[字符串/对象],[字符串])\r\n    style(node, name, value) {\r\n        //三个参数：dom.style(node,\"color\",\"red\")\r\n        if (arguments.length === 3) {\r\n            node.style[name] = value; //这里需要用[]号，不用的话name就直接变成name字符串了\r\n        }\r\n        //两个参数：dom.style(node,\"color\") \r\n        else if (arguments.length === 2) {\r\n            if (typeof name === \"string\") {\r\n                return node.style[name];\r\n            }\r\n            //两个参数：dom.style(node,{border:\"1px solid red\",color:\"red\"})\r\n            else if (name instanceof Object) {\r\n                for (let key in name) { //key属性名，name[key]属性值\r\n                    node.style[key] = name[key];\r\n                }\r\n            }\r\n        }\r\n    },\r\n    //添加、删除、判断节点的类\r\n    class: {\r\n        add(node, className) {\r\n            node.classList.add(className);\r\n        },\r\n        remove(node, className) {\r\n            return node.classList.remove(className);\r\n        },\r\n        has(node, className) {\r\n            return node.classList.contains(className)\r\n        }\r\n    },\r\n    //添加事件on(node,eventName,function)\r\n    on(node, eventName, fn) {\r\n        node.addEventListener(eventName, fn);\r\n    },\r\n    //移除事件off(node,eventName,function)\r\n    off(node, eventName, fn) {\r\n        node.removeEventListener(eventName, fn);\r\n    },\r\n    //获得多个元素或者在特定元素中找某个元素find(selector,nodescope)\r\n    find(selector, nodescope) {\r\n        return (nodescope || document).querySelectorAll(selector);\r\n    },\r\n    //获得一个节点的父节点parent(node)\r\n    parent(node) {\r\n        return node.parentNode;\r\n    },\r\n    //获得一个节点的全部子节点children(node)\r\n    children(node) {\r\n        return node.children;\r\n    },\r\n    //获得节点的所有兄弟节点但是除了自己 siblings(node)\r\n    siblings(node) {\r\n        //node.parentNode.children得到的是一个伪数组，需要通过Array.from()变成数组\r\n        //在调用数组的filter方法把自己这个节点去掉，剩下的节点通过数组的方式返回\r\n        return Array.from(node.parentNode.children).filter(n => n !== node);\r\n    },\r\n    //获得节点后面的一个兄弟节点 next(node)\r\n    next(node) {\r\n        // 获得节点的下一个兄弟节点\r\n        let x = node.nextSibling;\r\n        // 判断它的下一个兄弟节点是否存在，存在在判断它的节点类型是否是文本节点\r\n        while (x && x.nodeType === 3) { //文本节点的nodeType=3\r\n            x = x.nextSibling; //是文本节点，则再继续获得下一个兄弟节点\r\n        }\r\n        return x;\r\n    },\r\n    //获得节点前面的一个兄弟节点previous(node)\r\n    previous(node) {\r\n        // 获得节点的下一个兄弟节点\r\n        let x = node.previousSibling;\r\n        // 判断它的下一个兄弟节点是否存在，存在在判断它的节点类型是否是文本节点\r\n        while (x && x.nodeType === 3) { //文本节点的nodeType=3\r\n            x = x.previousSibling; //是文本节点，则再继续获得下一个兄弟节点\r\n        }\r\n        return x;\r\n    },\r\n    //遍历每个节点，执行处理函数fn each(nodeList)\r\n    // each.(nodeList,function fn(params) {\r\n    //    dom.style(params,{color:red})\r\n    // })\r\n    each(nodeList, fn) {\r\n        for (let i = 0; i < nodeList.length; i++) {\r\n            fn.call(null, nodeList[i]);\r\n        }\r\n    },\r\n    //获得节点在父节点中的索引  index(node)\r\n    index(node) {\r\n        //获得父节点中所有的子节点\r\n        const list = dom.children(node.parentNode);\r\n        let i = 0\r\n        for (i = 0; i < list.length; i++) {\r\n            if (list[i] === node) {\r\n                break;\r\n            }\r\n        }\r\n        return i; //这里是访问不到i的，所以i要声明到循环外面\r\n    }\r\n};"]}